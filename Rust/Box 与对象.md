对于多数高级语言往往会弱化堆栈的概念，它们通常由 GC 等方式来管理内存。而对于像 Rust 这类的低级语言来说，则需要更深入的了解堆栈的概念。

栈内存从高位地址向下增长，且栈内存是连续分配的，一般来说操作系统对栈内存的大小都有限制。这也是为什么 C 语言中无法创建任意长度的数组。在 Rust 中，`main` 线程的栈大小是 8MB，普通线程是 2MB。在函数调用时会在其中创建一个临时的栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 Drop 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预。因而栈内存申请和释放是非常高效的。

与栈相反，堆上的内存是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常不是连续的。因而从性能的角度看，栈内存往往更高。

除此之外，Rust 堆上的对象还有一个特殊之处，它们都拥有一个所有者。因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）。

```rust
fn main() -> Result<()> {
    let str = String::from("Hello world");
    println!("{}", str);
    let str2 = str;
    println!("{}", str);
    println!("{}", str2);

    Ok(())
}
```

在所有权的规则中，堆内存上的对象默认会转移所有权，所以 `str` 的指针引用转移给了 `str2`，