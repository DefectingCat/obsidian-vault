不同于那个神奇的语言，Rust 并不是所有的函数都是闭包，闭包有着特殊的声明方式。

```rust
fn main() {
    let x = 40;
    let sum = |y| x + y;
    println!("{:?}", sum(2))
}
```

同理，Rust 的闭包会可以捕获作用域中的值。同时对内存也是有一定影响的，当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。

而 Rust 中闭包复杂的在于借用与转移所有权。

## 三种 Fn 特征

闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的 `Fn` 特征也有三种：

1. `FnOnce` ，该类型的闭包捕获变量后获取了其所有权（例如返回了该变量）；

同时声明为闭包函数的变量也会随着如何使用被捕获的变量所决定实现了哪些特征。在 `FnOnce` 默认的情况下，该类型的闭包会直接拿走被捕获变量的所有权，所以该函数在使用一次后也会被 `move` 所以不能被调用两次。

```rust
fn main() {
    let arr = vec![1, 2, 3];
    let sum = |y| {
        arr;
    };
    exec(sum)
}

fn exec<F>(func: F)
where
    F: FnOnce(usize),
{
    println!("{:?}", func(2));
    println!("{:?}", func(3));
}
```

如果在闭包函数中不直接返回捕获到的变量，而是返回一个克隆。此时并不会直接转移被捕获到的变量的所有权，自然函数 `sum` 也实现了 `Copy` trait，则可以调用多次。

```rust
fn main() {
    let arr = vec![1, 2, 3];
    let sum = |y| {
        arr.clone();
    };
    exec(sum)
}

fn exec<F>(func: F)
where
    F: FnOnce(usize) + Copy,
{
    println!("{:?}", func(2));
    println!("{:?}", func(3));
}
```

2. `FnMut`，该类型的函数修改了（mutate）捕获到的变量；

该闭包可以修改捕获到的变量，也就是捕获了它的可变引用。同时函数自身声明的变量也需要标记为可变的。这种写法有点反直觉，但是如果仅仅将 `sum` 函数当作是一个变量就比较合理了。

```rust
fn main() {
    let mut str = String::from("Hello");
    let mut sum = |s| {
        str.push_str(s);
    };
    sum(" world");
    println!("{}", str)
}
```

3. `Fn`，该类型的函数以不可变借用捕获了变量；

同理，在闭包中以不可变引用的方式使用了捕获的变量，则该闭包会自动实现 `Fn` 特性。同时也不需要将其标记为 `mut`。

```rust
fn main() {
    let str = String::from("Hello");
    let sum = |s| {
        println!("{}{}", str, s);
    };
    sum(" world");
}
```

**一个闭包实现了哪种 `Fn` 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们。**

### 多个特征

一个闭包函数同时可以实现 3 个特征中的多个