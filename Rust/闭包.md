不同于那个神奇的语言，Rust 并不是所有的函数都是闭包，闭包有着特殊的声明方式。

```rust
fn main() {
    let x = 40;
    let sum = |y| x + y;
    println!("{:?}", sum(2))
}
```

同理，Rust 的闭包会可以捕获作用域中的值。同时对内存也是有一定影响的，当闭包从环境中捕获一个值时，会分配内存去存储这些值。对于有些场景来说，这种额外的内存分配会成为一种负担。与之相比，函数就不会去捕获这些环境值，因此定义和使用函数不会拥有这种内存负担。

而 Rust 中闭包复杂的在于借用与转移所有权。

## 三种 Fn 特征

闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的 `Fn` 特征也有三种：

1. `FnOnce` ，该类型的闭包会直接拿走被捕获变量的所有权。

同时声明为闭包函数的变量也会随着如何使用被捕获的变量所决定实现了哪些特征。在 `FnOnce` 默认的情况下，该类型的闭包会直接拿走被捕获变量的所有权，所以该函数在使用一次后也会被 `move` 所以不能被调用两次。

```rust
fn main() {
    let arr = vec![1, 2, 3];
    let sum = |y| {
        arr;
    };
    exec(sum)
}

fn exec<F>(func: F)
where
    F: FnOnce(usize),
{
    println!("{:?}", func(2));
    println!("{:?}", func(3));
}
```