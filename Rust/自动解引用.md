Rust 中的常规引用与大多数语言相同，对常规引用使用 `*` 操作符，久开业i通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let n = 40;
    let t = &n;
    let sum = *t + 2;
    dbg!(&sum);
}
```

这里的 `t` 就是一个常规引用，它包含了值 40 所在的内存地址，然后通过解引用 `*t` 就能得到值 40。

## 智能指针解引用

Rust 将解引用提升到了一个新的高度，当面对一个非常规引用时，编译器显然不知道该如何解引用。因此我们可以为指针指针结构体实现 `Deref` 特征。

实现了 `Deref` 后的智能指针结构体，就可以像普通引用一样，通过 `*` 进行解引用。例如 `Box<T>` 智能指针：

```rust
fn main() {
    let n = Box::new(40);
    let sum = *n + 2;
    dbg!(&sum);
}
```

当对 Box 智能指针解引用时看起来和常规引用并没有什么不一样的地方。这是因为编译器隐式的调用了 `Deref` 特征中的方法。

### 定义自己的智能指针

我们定义一个和 Box 类似的指针指针，由于 Box 本身就很简单，并没有包含如长度，最大长度等信息，所以就使用一个元组结构体即可够用。

```rust
struct RUABox<T>(T);

impl<T> RUABox<T> {
    fn new(n: T) -> Self {
        Self(n)
    }
}
```

此时还未实现 `Deref` 特征，所以解引用 `*` 肯定会报错。

现在来为 `RUABox` 实现 `Deref`  特征，以支持 `*` 解引用：

```rust
use std::ops::Deref;

impl<T> Deref for RUABox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

和实现其他 Trait 一样，实现 `Deref` 也是这么方便。