Rust 中的常规引用与大多数语言相同，对常规引用使用 `*` 操作符，久开业i通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let n = 40;
    let t = &n;
    let sum = *t + 2;
    dbg!(&sum);
}
```

这里的 `t` 就是一个常规引用，它包含了值 40 所在的内存地址，然后通过解引用 `*t` 就能得到值 40。

## 智能指针解引用

Rust 将解引用提升到了一个新的高度，当面对一个非常规引用时，编译器显然不知道该如何解引用。因此我们可以为指针指针结构体实现 `Deref` 特征。

实现了 `Deref` 后的智能指针结构体，就可以像普通引用一样，通过 `*` 进行解引用。例如 `Box<T>` 智能指针：

```rust
fn main() {
    let n = Box::new(40);
    let sum = *n + 2;
    dbg!(&sum);
}
```

当对 Box 智能指针解引用时看起来和常规引用并没有什么不一样的地方。这是因为编译器隐式的调用了 `Deref` 特征中的方法。

### 定义自己的智能指针

我们定义一个和 Box 类似的指针指针，由于 Box 本身就很简单，并没有包含如长度，最大长度等信息，所以就使用一个元组结构体即可够用。

```rust
struct RUABox<T>(T);

impl<T> RUABox<T> {
    fn new(n: T) -> Self {
        Self(n)
    }
}
```

此时还未实现 `Deref` 特征，所以解引用 `*` 肯定会报错。

现在来为 `RUABox` 实现 `Deref`  特征，以支持 `*` 解引用：

```rust
use std::ops::Deref;

impl<T> Deref for RUABox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

和实现其他 Trait 一样，实现 `Deref` 也是这么方便。

### * 背后

当我们对智能指针进行解引用时，实际上 Rust 为我们调用了以下方法：

```rust
*(n.deref())
```

首先调用 `deref` 方法返回值的常规引用，然后通过 `*` 对常规引用进行解引用，最终获取到目标的值。

使用这种方式实现的原因在于所有权系统的存在。如果 `deref` 方法直接返回一个值，而不是引用，那么该值的所有权就会被转移给调用者，而我们并不希望调用者仅仅只是 `*T` 一下，就拿走了指针指针中包含的值。

需要注意的是，`*` 不会无限递归替换。从 `*` 到 `*(y.deref*())` 只会发生一次，而不会继续进行替换然后产生形如 `*((y.deref()).deref())` 的怪物。

## 函数和方法中的隐式解引用

若一个类型实现了 `Deref` 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 `Deref` 转换。