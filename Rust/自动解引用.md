Rust 中的常规引用与大多数语言相同，对常规引用使用 `*` 操作符，通过解引用的方式获取到内存地址对应的数据值：

```rust
fn main() {
    let n = 40;
    let t = &n;
    let sum = *t + 2;
    dbg!(&sum);
}
```

这里的 `t` 就是一个常规引用，它包含了值 40 所在的内存地址，然后通过解引用 `*t` 就能得到值 40。

## 智能指针解引用

Rust 将解引用提升到了一个新的高度，当面对一个非常规引用时，编译器显然不知道该如何解引用。因此我们可以为指针指针结构体实现 `Deref` 特征。

实现了 `Deref` 后的智能指针结构体，就可以像普通引用一样，通过 `*` 进行解引用。例如 `Box<T>` 智能指针：

```rust
fn main() {
    let n = Box::new(40);
    let sum = *n + 2;
    dbg!(&sum);
}
```

当对 Box 智能指针解引用时看起来和常规引用并没有什么不一样的地方。这是因为编译器隐式的调用了 `Deref` 特征中的方法。

### 定义自己的智能指针

我们定义一个和 Box 类似的指针指针，由于 Box 本身就很简单，并没有包含如长度，最大长度等信息，所以就使用一个元组结构体即可够用。

```rust
struct RUABox<T>(T);

impl<T> RUABox<T> {
    fn new(n: T) -> Self {
        Self(n)
    }
}
```

此时还未实现 `Deref` 特征，所以解引用 `*` 肯定会报错。

现在来为 `RUABox` 实现 `Deref`  特征，以支持 `*` 解引用：

```rust
use std::ops::Deref;

impl<T> Deref for RUABox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

和实现其他 Trait 一样，实现 `Deref` 也是这么方便。

### * 背后

当我们对智能指针进行解引用时，实际上 Rust 为我们调用了以下方法：

```rust
*(n.deref())
```

首先调用 `deref` 方法返回值的常规引用，然后通过 `*` 对常规引用进行解引用，最终获取到目标的值。

使用这种方式实现的原因在于所有权系统的存在。如果 `deref` 方法直接返回一个值，而不是引用，那么该值的所有权就会被转移给调用者，而我们并不希望调用者仅仅只是 `*T` 一下，就拿走了指针指针中包含的值。

需要注意的是，`*` 不会无限递归替换。从 `*` 到 `*(y.deref*())` 只会发生一次，而不会继续进行替换然后产生形如 `*((y.deref()).deref())` 的怪物。

## 函数和方法中的隐式解引用

若一个类型实现了 `Deref` 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 `Deref` 转换。

```rust
fn main() {
    let hello = String::from("Hello");
    display(&hello);
}

fn display(s: &str) {
    println!("{s}");
}
```

以上代码有几点值得注意：

* `String` 实现了 `Deref` 特征，可以在需要时自动被转换为 `&str` 类型；
* `&s` 是一个 `&String` 类型，当它被传给 `display` 函数时，自动通过 `Deref` 转换成了 `&str`；
* 必须使用 `&s` 的方式来触发 `Deref`（仅引用类型的实参数才会触发自动解引用）；

## 三种 Deref 转换

-   当 `T: Deref<Target=U>`，可以将 `&T` 转换成 `&U`，也就是我们之前看到的例子；
-   当 `T: DerefMut<Target=U>`，可以将 `&mut T` 转换成 `&mut U`；
-   当 `T: Deref<Target=U>`，可以将 `&mut T` 转换成 `&U`；

对于上述三条规则中的第三条，它比另外两条稍微复杂了点：Rust 可以把可变引用隐式的转换成不可变引用，但反之则不行。

如果从 Rust 的所有权和借用规则的角度考虑，当你拥有一个可变的引用，那该引用肯定是对应数据的唯一借用，那么此时将可变引用变成不可变引用并不会破坏借用规则；但是如果你拥有一个不可变引用，那同时可能还存在其它几个不可变的引用，如果此时将其中一个不可变引用转换成可变引用，就变成了可变引用与不可变引用的共存，最终破坏了借用规则。