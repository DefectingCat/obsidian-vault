谈及内存管理，我们希望编程语言具备两个特点：

- 希望能在我们选定的时机及时释放，这使我们能控制程序的内存消耗；
- 在对象被释放后，我们绝不希望继续使用指向它的指针，这是未定义行为，会导致崩溃和安全漏洞。

在使用指向一个堆内存的指针时，人们普遍认为，虽然其他代码也可以创建指向拥有内存的临时指针，但是在拥有者决定销毁拥有对象之前，其他代码有责任确保其指针已消失。这便是所有权的示例，拥有者决定被拥有者的生命周期，其他所有人都必须尊重其决定。

然而，在 Rust 中，所有权这个概念内置于语言本身，并通过编译期检查强制执行。每个值都有决定其生命周期的唯一拥有者。当游泳者被释放时，它拥有的值也会同时被释放，在 Rust 术语中，释放的行为被称为**丢弃**（drop）。

Rust 的 Box 类型是所有权的另一个例子。`Box<T>` 是指向在堆上的 `T` 类型值的指针。因为 Box 拥有它所指向的空间，所以当丢弃 Box 时，也会释放此空间。

```rust
let point = Box::new((0.625, 0.5));
let label = format!("{:?}", point);
println!("Point {}", label);
```

就像变量拥有自己的值一样，结构体拥有自己的字段，元组、数组和向量拥有自己的元素。

```rust
struct Person {
    name: String,
    age: u32,
}

let composers = vec![
    Person {
        name: "xfy".to_string(),
        age: 18,
    },
    Person {
        name: "dfy".to_string(),
        age: 18,
    },
    Person {
        name: "Sonetto".to_string(),
        age: 18,
    },
];

composers.iter().for_each(|composer| {
    println!("{}, age {}", composer.name, composer.age);
});
```

这里有很多所有权关系，但每个都一目了然：`composers` 变量拥有一个向量，向量拥有自己的元素，每个元素都是一个 `Person` 结构体，每个结构体都拥有自己的字段，并且字符串拥有自己的文本。当控制流离开声明 `composers` 的作用域时，程序会丢弃自己的值并将整棵所有权树一起丢弃。

所有权关系的重要性：每个值都有一个唯一的拥有者，因此很容易决定何时丢弃它。但是每个值可能会拥有许多其他值，这些值还可能拥有其他值。