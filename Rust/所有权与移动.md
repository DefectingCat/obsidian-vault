谈及内存管理，我们希望编程语言具备两个特点：

- 希望能在我们选定的时机及时释放，这使我们能控制程序的内存消耗；
- 在对象被释放后，我们绝不希望继续使用指向它的指针，这是未定义行为，会导致崩溃和安全漏洞。

在使用指向一个堆内存的指针时，人们普遍认为，虽然其他代码也可以创建指向拥有内存的临时指针，但是在拥有者决定销毁拥有对象之前，其他代码有责任确保其指针已消失。这便是所有权的示例，拥有者决定被拥有者的生命周期，其他所有人都必须尊重其决定。

然而，在 Rust 中，所有权这个概念内置于语言本身，并通过编译期检查强制执行。每个值都有决定其生命周期的唯一拥有者。当游泳者被释放时，它拥有的值也会同时被释放，在 Rust 术语中，释放的行为被称为**丢弃**（drop）。

Rust 的 Box 类型是所有权的另一个例子。`Box<T>` 是指向在堆上的 `T` 类型值的指针。因为 Box 拥有它所指向的空间，所以当丢弃 Box 时，也会释放此空间。

```rust
let point = Box::new((0.625, 0.5));
let label = format!("{:?}", point);
println!("Point {}", label);
```

就像变量拥有自己的值一样，结构体拥有自己的字段，元组、数组和向量拥有自己的元素。

```rust
struct Person {
    name: String,
    age: u32,
}

let composers = vec![
    Person {
        name: "xfy".to_string(),
        age: 18,
    },
    Person {
        name: "dfy".to_string(),
        age: 18,
    },
    Person {
        name: "Sonetto".to_string(),
        age: 18,
    },
];

composers.iter().for_each(|composer| {
    println!("{}, age {}", composer.name, composer.age);
});
```

这里有很多所有权关系，但每个都一目了然：`composers` 变量拥有一个向量，向量拥有自己的元素，每个元素都是一个 `Person` 结构体，每个结构体都拥有自己的字段，并且字符串拥有自己的文本。当控制流离开声明 `composers` 的作用域时，程序会丢弃自己的值并将整棵所有权树一起丢弃。

所有权关系的重要性：每个值都有一个唯一的拥有者，因此很容易决定何时丢弃它。但是每个值可能会拥有许多其他值，这些值还可能拥有其他值。

由此可见，拥有者及其拥有那些值形成了一棵树：值的拥有者时值的父节点，值拥有的值时值的字节点。每棵树的总根都是一个变量，当该变量超出作用域时，整棵树都将随之消失。

从某种意义上来说，Rust 确实不如其他语言强大：其他所有使用的编程语言都允许你构建出任意复杂的对象图，这些对象可以以我们认为合适的方式相互引用。

>解决问题的方式通常时灵活多样的，因此总是会有一些完美的解决方案能同时满足它所施加的限制。

单一所有权的概念仍然过于严格，还处理不了某些场景。Rust 从几个方面拓展了这种简单的思想。

- 可以将值从一个拥有者转移给另一个拥有者。这允许我们构建、重新排列和拆除树形结构。
- 像整数、浮点数和字符这样的非常简单的类型，不受所有权规则的约束。这些称之为 Copy 类型。（通常是存在栈上可复制的类型）
- 标准库提供了引用计数指针类型 Rc 和 Arc，它们允许值在某些限制下有多个拥有者。
- 可以对值进行”借用“（borrow），以获得值的引用。这种引用是非拥有型指针，有着受限的生命周期。
