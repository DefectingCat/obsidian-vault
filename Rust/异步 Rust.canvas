{
	"nodes":[
		{"id":"1c95381023bfc39d","x":-780,"y":340,"width":380,"height":240,"type":"text","text":"Future trait\n\n实现 `poll` 方法。\n\n在 `poll` 方法中，任务未完成返回 `Poll::Pending`，完成了则返回 `Poll::Ready(())`。\n\nFuture 是惰性的，只由执行器 `poll` 一次，Pending 之后由 `poll` 方法中的 `cx: &mut Context<'_>` 中 `cx.waker()` 来再次唤醒执行器。从而实现异步的功能。\n\n```rust\nimpl Future for TimerFuture {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // 通过检查共享状态，来确定定时器是否已经完成\n        let mut shared_state = self.shared_state.lock().unwrap();\n        if !shared_state.started {\n            let thread_shared_state = self.shared_state.clone();\n            thread::spawn(move || {\n                let mut shared_state = thread_shared_state.lock().unwrap();\n                println!(\"start first execute\");\n                shared_state.started = true;\n                thread::sleep(shared_state.duration);\n                // 通知执行器定时器已经完成，可以继续`poll`对应的`Future`了\n                shared_state.completed = true;\n                if let Some(waker) = shared_state.waker.take() {\n                    waker.wake()\n                }\n            });\n        }\n        if shared_state.completed {\n            Poll::Ready(())\n        } else {\n            // 设置 `wkaer`，这样新线程在睡眠结束后可以唤醒当前的任务，接着再次对 `Furture` 进行\n            // `poll` 操作\n            //\n            // 下面的`clone`每次被`poll`时都会发生一次，实际上，应该是只`clone`一次更加合理。\n            // 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，\n            // 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\n```"},
		{"id":"66b7ede461a4f0fa","type":"text","text":"执行器\n\n执行器负责接收发送过来的 Future，并执行一次 `poll` 方法，在执行 `poll` 方法时，将 `waker` 放入 `poll` 参数的 `Content<'_>` 中。由后续 Future 自身执行完毕后再调用唤醒执行器继续执行该 Future 的 `poll` 方法。\n\n```rust\n/// 任务执行器，负责从通道中接收任务然后执行 \npub struct Executor { pub ready_queue: Receiver<Arc<Task>>, }\n```","x":120,"y":-100,"width":380,"height":240},
		{"id":"308d31fa7a959dea","type":"text","text":"Spawner\n\nSpawner 用于将 Future 包装成一个 Task，然后发送给执行器。顺便在 Task 中带上自身的发送方法，后续的 `waker` 实际上就是调用该发送方法，将 Future 再次发送给执行器实现再次 `poll`。\n\n```rust\n#[derive(Clone)]\npub struct Spawner {\n    pub task_sender: SyncSender<Arc<Task>>,\n}\n```","x":120,"y":780,"width":380,"height":240},
		{"id":"dd2fde21ae57f92a","x":150,"y":400,"width":320,"height":120,"type":"text","text":"Task\n\n封装一个 Future 和一个发送用的消息信道的 Sender。用于在执行器和 Future 自身之间传递。第一次发送给执行器后，后续 Future 通过调用 `waker` 来将自身发送给执行器。\n\n```rust\n/// 一个Future，它可以调度自己(将自己放入任务通道中)，然后等待执行器去`poll`\npub struct Task {\n    /// 进行中的Future，在未来的某个时间点会被完成\n    ///\n    /// 按理来说`Mutex`在这里是多余的，因为我们只有一个线程来执行任务。但是由于\n    /// Rust并不聪明，它无法知道`Future`只会在一个线程内被修改，并不会被跨线程修改。因此\n    /// 我们需要使用`Mutex`来满足这个笨笨的编译器对线程安全的执着。\n    ///\n    /// 如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`\n    pub future: Mutex<Option<BoxFuture<'static, ()>>>,\n\n    /// 可以将该任务自身放回到任务通道中，等待执行器的poll\n    pub task_sender: SyncSender<Arc<Task>>,\n}\n```\n\n我们只需要实现一个方法 `wake_by_ref`，它就是 `wake` 的核心所在。当调用 `wake` 时，它将 clone 自身的 Arc 并发送到任务通道。\n\n```rust\nimpl ArcWake for Task {\n    fn wake_by_ref(arc_self: &Arc<Self>) {\n        let cloned = arc_self.clone();\n        arc_self.task_sender.send(cloned).expect(\"任务队列已满\");\n    }\n}\n```"}
	],
	"edges":[
		{"id":"a51250a55b7506c5","fromNode":"308d31fa7a959dea","fromSide":"left","toNode":"1c95381023bfc39d","toSide":"right","label":"封装为 Task"},
		{"id":"3d4fa73cb08c83b1","fromNode":"1c95381023bfc39d","fromSide":"right","toNode":"dd2fde21ae57f92a","toSide":"left","label":"封装为 Task"},
		{"id":"e1392cd5030932db","fromNode":"308d31fa7a959dea","fromSide":"right","toNode":"66b7ede461a4f0fa","toSide":"right","label":"发送封装好的 Task"},
		{"id":"8235a0b0a135ddc2","fromNode":"66b7ede461a4f0fa","fromSide":"left","toNode":"1c95381023bfc39d","toSide":"top","label":"第一次执行 poll"},
		{"id":"a9b9e14919ee3471","fromNode":"1c95381023bfc39d","fromSide":"top","toNode":"66b7ede461a4f0fa","toSide":"bottom","label":"调用 waker"}
	]
}