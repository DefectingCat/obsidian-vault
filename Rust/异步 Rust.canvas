{
	"nodes":[
		{"id":"1c95381023bfc39d","x":-180,"y":-20,"width":380,"height":240,"type":"text","text":"Future trait\n\n实现 `poll` 方法。\n\n在 `poll` 方法中，任务未完成返回 `Poll::Pending`，完成了则返回 `Poll::Ready(())`。\n\nFuture 是惰性的，只由执行器 `poll` 一次，Pending 之后由 `poll` 方法中的 `cx: &mut Context<'_>` 中 `cx.waker()` 来再次唤醒执行器。从而实现异步的功能。\n\n```rust\nimpl Future for TimerFuture {\n    type Output = ();\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // 通过检查共享状态，来确定定时器是否已经完成\n        let mut shared_state = self.shared_state.lock().unwrap();\n        if !shared_state.started {\n            let thread_shared_state = self.shared_state.clone();\n            thread::spawn(move || {\n                let mut shared_state = thread_shared_state.lock().unwrap();\n                println!(\"start first execute\");\n                shared_state.started = true;\n                thread::sleep(shared_state.duration);\n                // 通知执行器定时器已经完成，可以继续`poll`对应的`Future`了\n                shared_state.completed = true;\n                if let Some(waker) = shared_state.waker.take() {\n                    waker.wake()\n                }\n            });\n        }\n        if shared_state.completed {\n            Poll::Ready(())\n        } else {\n            // 设置 `wkaer`，这样新线程在睡眠结束后可以唤醒当前的任务，接着再次对 `Furture` 进行\n            // `poll` 操作\n            //\n            // 下面的`clone`每次被`poll`时都会发生一次，实际上，应该是只`clone`一次更加合理。\n            // 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，\n            // 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务\n            shared_state.waker = Some(cx.waker().clone());\n            Poll::Pending\n        }\n    }\n}\n```"},
		{"id":"66b7ede461a4f0fa","type":"text","text":"执行器","x":45,"y":236,"width":380,"height":240}
	],
	"edges":[]
}