与其他多数语言不同的是，Rust 既没有 GC 也不需要我们手动的去释放内存。换来的则是新的生命周期的概念，简而言之就是引用的有效作用域。

在通常情况下，Rust 会在一个作用域结束时释放变量。当我们将变量 `b` 的引用赋值给 `a` 后，在块级作用域结束后，变量 `b` 则会被释放，此时再访问 `a` 指向的就是一个空引用了。

```rust
fn main() {
    let a;
    {
        let b = 5;
        a = &b;
    }
    println!("a {}", a)
}
```

> `i32` 实现了 `Copy` trait，直接将 `b` 赋值给 `a` 则会拷贝值，从而 `b` 被丢弃了也没关系。

## 生命周期消除

实际上，对于编译器来说，每个引用都有一个生命周期。但在我们使用的时候却无需为每一个引用值都手动标记生命周期。

```rust
fn first_world(worlds: &str) -> &str {
    let bytes = worlds.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &worlds[..i];
        }
    }

    worlds
}
```

对于函数 `first_world` 来说，它的返回值是一个引用类型，那么这个引用类型只有两个情况：

* 从参数获取；
* 从函数内部创建；

如果是后者，则该引用会在函数执行完毕后被释放，就会出现垂悬引用，最终被编译器拒绝。因此只剩下一种情况，返回值是从来自参数，这就意味着参数和返回值的生命周期是一样的。道理很简单，因此编译器也能很轻松的推断出来。

***函数或者方法中，参数的生命周期被称为 `输入生命周期`，返回值的生命周期被称为 `输出生命周期` 

### 消除规则

编译器使用三条规则来判读哪些场景不需要显式的标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条规则应用在输出生命周期上。

1. 每个参数都会获得独自的生命周期。