Rust 所有权规则：

1. Rust 中每个值都被一个变量所拥有，该变量被称之为值的拥有者；
2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者；
3. 当所有者（变量）离开作用域范围时，这个值将被丢弃（drop）；

借用规则：

* 同一时刻，要么只拥有一个可变引用，要么任意多个不可变引用。
* 引用必须是有效的。

根据所有权机制，一个值只能有一个所有者。大多数情况下这个机制都能适用，只有在少数情况下无法适用：

* 在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理。
* 在多线程中，多个线程可能会持有同一个数据，但是受限于 Rust 的安全机制，无法同时获取该数据的可变引用。

对于一个资源在同一时刻需要多个所有者时，Rust 提供了通过引用计数的方式，来允许多个所有者。

这种实现机制就是 `Rc` 和 `Arc`，前者适用于单线程，后者适用于多线程。

## 引用计数

`Rc<T>`  Reference counting，通过记录一个数据被引用的次数来确定该数据是否正在被适用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。

在通常情况下，一个在堆内存上的数据被赋值到另一个变量时，根据所有权机制，一个数据只能拥有一个所有者。所以数据会发生所有权转移（move）：

```rust
fn main() {
    let s = String::from("Hello world");
    let a = Box::new(s);  // s 的数据所有权被转移到 a
    let b = Box::new(s);  // 试图将 s 到所有权再转移到 b
}
```

在将 `s` 转移给 `a` 后再试图将转移给 `b` 就会得到所有权被转移到报错。编译器分别给了非常详细的提示：

* 发生所有权转移，因为 `s` 没有实现 `Copy` trait；
* 值被转移给变量 `a`；
* 再值被转移后尝试再次使用它；

```shell
error[E0382]: use of moved value: `s`
 --> src/main.rs:8:22
  |
6 |     let s = String::from("Hello world");
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
7 |     let a = Box::new(s);
  |                      - value moved here
8 |     let b = Box::new(s);
  |                      ^ value used here after move
  |
help: consider cloning the value if the performance cost is acceptable
  |
7 |     let a = Box::new(s.clone());
  |                       ++++++++
```

