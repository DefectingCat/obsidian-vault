在构建一个多线程服务器之前，需要先了解下不同语言实现的不同并发模型：

-   由于操作系统提供了创建线程的 API，因此部分语言会直接调用该 API 来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为**1:1 线程模型**，例如 Rust。
-   还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为**M:N 线程模型**，其中 M 和 N 并没有特定的彼此限制关系。一个典型的代表就是 Go 语言。
-   还有些语言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang 语言。

总之，每一种模型都有其优缺点及选择上的权衡，而 Rust 在设计时考虑的权衡就是运行时(Runtime)。出于 Rust 的系统级使用场景，且要保证调用 C 时的极致性能，它最终选择了尽量小的运行时实现。

而绿色线程/协程的实现会显著增大运行时的大小，因此 Rust 只在标准库中提供了 `1:1` 的线程模型，如果需要牺牲一些性能来换取更精确的线程控制以及更小的线程上下文切换成本，那么可以选择 Rust 中的 `M:N` 模型，这些模型由三方库提供了实现，例如大名鼎鼎的 `tokio`。

## 构建单线程 Web 服务器

中所周知，Web 服务器使用的是 HTTP 传输协议，它属于**请求 - 响应**协议，也就是说有客户的来发起请求，同时有服务端来响应客户的请求。请求与响应的内容又协议的本身定义。

同时 HTTP 基于 TCP 协议，TCP 是一个底层协议，它描述了信息如何从一端到达另一端的细节。不过并不指定信息是什么，而 HTTP 就负责定义了请求与响应的内容。

### 监听 TCP 链接

与多数语言不同的是，我们需要从监听 TCP 链接开始来构建我们的 HTTP 服务器。标准库提供了 `std::net` 模块处理这些功能。

```rust
fn main() {
    let listener  = TcpListener::bind("127.0.0.1:4000").expect("cannon listen on port 4000");
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        println!("Connection established!");
    }
}
```

这段代码会在地址 `127.0.0.1:4000` 上监听传入的 TCP 流。当获取到传入的流，它会打印出 `Connection established!`

这里的 `bind` 方法类似于 `new` 方法，它用于创建一个 `TcpListener`  实例。这个方法叫做 `bind` 完全是因为在网络领域监听一个端口被称之为“绑定到一个端口”。

`TcpListener` 的 `incoming` 方法返回一个迭代器，它提供了一系列的流（更准确的说是 `TcpStream` 类型的流）。**流**（_stream_）代表一个客户端和服务端之间打开的连接。**连接**（_connection_）代表客户端连接服务端、服务端生成响应以及服务端关闭连接的全部请求 / 响应过程。

这时候当我们尝试向 `127.0.0.1:4000` 发送 HTTP 请求时，终端就会打印 `Connection established!`。

```zsh
❯ curl 127.0.0.1:4000
curl: (56) Recv failure: Connection reset by peer
```

但无论是浏览器还是其他客户端都会显示请求失败等信息，这是因为我们收到来自客户端等请求后并没有返回任何信息。

### 读取请求

在响应客户端的请求之前，我们需要先能够读取客户端发送过来的信息。为了分离获取链接和接下来的代码逻辑更加清晰，这里将新建个新的函数来负责读取请求。