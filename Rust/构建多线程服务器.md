在构建一个多线程服务器之前，需要先了解下不同语言实现的不同并发模型：

-   由于操作系统提供了创建线程的 API，因此部分语言会直接调用该 API 来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为**1:1 线程模型**，例如 Rust。
-   还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为**M:N 线程模型**，其中 M 和 N 并没有特定的彼此限制关系。一个典型的代表就是 Go 语言。
-   还有些语言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang 语言。

总之，每一种模型都有其优缺点及选择上的权衡，而 Rust 在设计时考虑的权衡就是运行时(Runtime)。出于 Rust 的系统级使用场景，且要保证调用 C 时的极致性能，它最终选择了尽量小的运行时实现。

而绿色线程/协程的实现会显著增大运行时的大小，因此 Rust 只在标准库中提供了 `1:1` 的线程模型，如果需要牺牲一些性能来换取更精确的线程控制以及更小的线程上下文切换成本，那么可以选择 Rust 中的 `M:N` 模型，这些模型由三方库提供了实现，例如大名鼎鼎的 `tokio`。

## 构建单线程 Web 服务器

中所周知，Web 服务器使用的是 HTTP 传输协议，它属于**请求 - 响应**协议，也就是说有客户的来发起请求，同时有服务端来响应客户的请求。请求与响应的内容又协议的本身定义。

同时 HTTP 基于 TCP 协议，TCP 是一个底层协议，它描述了信息如何从一端到达另一端的细节。不过并不指定信息是什么，而 HTTP 就负责定义了请求与响应的内容。

### 监听 TCP 链接

与多数语言不同的是，我们需要从监听 TCP 链接开始来构建我们的 HTTP 服务器。标准库提供了 `std::net` 模块处理这些功能。

```rust
fn main() {
    let listener  = TcpListener::bind("127.0.0.1:4000").expect("cannon listen on port 4000");
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        println!("Connection established!");
    }
}
```

这段代码会在地址 `127.0.0.1:4000` 上监听传入的 TCP 流。当获取到传入的流，它会打印出 `Connection established!`

这里的 `bind` 方法类似于 `new` 方法，它用于创建一个 `TcpListener`  实例。这个方法叫做 `bind` 完全是因为在网络领域监听一个端口被称之为“绑定到一个端口”。

`TcpListener` 的 `incoming` 方法返回一个迭代器，它提供了一系列的流（更准确的说是 `TcpStream` 类型的流）。**流**（_stream_）代表一个客户端和服务端之间打开的连接。**连接**（_connection_）代表客户端连接服务端、服务端生成响应以及服务端关闭连接的全部请求 / 响应过程。

这时候当我们尝试向 `127.0.0.1:4000` 发送 HTTP 请求时，终端就会打印 `Connection established!`。

```zsh
❯ curl 127.0.0.1:4000
curl: (56) Recv failure: Connection reset by peer
```

但无论是浏览器还是其他客户端都会显示请求失败等信息，这是因为我们收到来自客户端等请求后并没有返回任何信息。

### 读取请求

在响应客户端的请求之前，我们需要先能够读取客户端发送过来的信息。为了分离获取链接和接下来的代码逻辑更加清晰，这里将新建个新的函数来负责读取请求。

```rust
fn handle_connection(mut stream: &TcpStream) {
    let buf_reader = BufReader::new(&mut stream);
    let http_request: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    dbg!(&http_request);
}
```

这里将 `use std::io::{BufRead, BufReader};` 引入来获取读写流所需的特定 Trait。

在 `handle_connection` 中，我们新建了一个 `BufReader` 实例来封装 `stream` 的可变引用。`BufReader` 增加了缓存来替我们管理 `std::io::Read` trait 方法的调用。

`BufReader` 实现了 `std::io::BufRead` trait，它提供了 `lines` 方法。`lines` 方法通过遇到换行符（newline）字节就切分数据流的方式返回一个 `Result<String,std::io::Error>` 的迭代器。为了获取每一个 `String`，通过 map 并 `unwrap` 每一个 `Result`。如果数据不是有效的 UTF-8 编码或者读取流遇到问题时，`Result` 可能是一个错误。一如既往生产环境的程序应该更优雅地处理这些错误，不过出于简单的目的我们选择在错误情况下停止程序。

除此之外，HTTP 客户端通过连续发送两个换行符来表示一个 HTTP 请求的结束，所以为了从 TCP 流中获取一个完整的 HTTP 请求，我们需要获取行直到它们不为空。并通过 `collect()` 方法将其收集为一个 Vector。

```zsh
[src/main.rs:20] &http_request = [
    "GET / HTTP/1.1",　
    "Host: 127.0.0.1:4000",
    "User-Agent: curl/7.86.0",
    "Accept: */*",
    "",
]
```

  再次运行我们的服务端并发送一个请求，就可以看到刚刚客户端给我们发送了哪些信息了。

### HTTP 请求的详细内容

HTTP 是一个基于文本的协议，同时一个请求有如下格式：

```txt
Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
```

第一行叫做**请求行**，它存放了客户端请求了哪些信息。这里分别是 method：所使用的请求方式，例如常见的 GET 和 POST，就是存放在这里的。

接下来的部分是 `/`，它代表客户端请求的统一资源标识符 URI，和 URL 比较类似但不完全一样。

最后一部分是客户端使用的 HTTP 版本，和请求以那种换行符结束。换行符结束这部分现代多数客户端可能不会表明。

从刚刚 curl 发送的请求第一行  `"GET / HTTP/1.1"` 则表明：GET 请求，`/` 路径，HTTP 版本 1.1。

从 `Host:` 字段开始剩下的全部都是 headers，GET 请求没有 body。

curl 发送的请求可能比较含蓄，如果使用浏览器来请求我们的服务端，就会发现浏览器携带了非常多的 headers：

```zsh
[src/main.rs:20] &http_request = [
    "GET / HTTP/1.1",
    "Host: localhost:4000",
    "Connection: keep-alive",
    "sec-ch-ua: \"Not_A Brand\";v=\"99\", \"Google Chrome\";v=\"109\", \"Chromium\";v=\"109\"",
    "sec-ch-ua-mobile: ?0",
    "sec-ch-ua-platform: \"macOS\"",
    "DNT: 1",
    "Upgrade-Insecure-Requests: 1",
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
    "Sec-Fetch-Site: none",
    "Sec-Fetch-Mode: navigate",
    "Sec-Fetch-User: ?1",
    "Sec-Fetch-Dest: document",
    "Accept-Encoding: gzip, deflate, br",
    "Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7",
    "",
]
```

