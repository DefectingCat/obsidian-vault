众所周知，React 并没有实现细颗粒度的状态更新。同时在副作用中也需要我们手动去管理对应依赖。如常见的 `useEffect` 和 `useMemo` 等：

```ts
const [count, setCount] = useState(0);
useEffect(() => {
  console.log('count updated ', count);
}, [count]);
```

这里就需要我们手动的去管理 `useEffect` 的依赖，否则 `useEffect` 则只会执行一次。而在 Vue 等框架中，则可以自动追踪其依赖：

```ts
const y = coumputed(() => x.value * 2 + 1);
```

在 Vue 和 Mobx 等框架中使用的“能自动追踪依赖的技术”被称为“细颗粒度更新”（Fine-Grained Reactivity），这也是许多前端框架响应式的原理。

## 实现一个细颗粒度更新

我们希望为 React 实现一个简易的细颗粒度更新的状态，使我们在使用副作用时不需要手动管理其依赖的 hooks。

其设想的效果应如下：

```ts
const [count, setCount] = useState(0);
useEffect(() => {
	console.log('count is ', count());
});
useEffect(() => {
	console.log('only print once');
});

// Trigger effect
setCount(1);
```

`useEffect` 不再需要为其手动管理状态，而是自动追踪依赖。当我们更新状态 `count` 时，自动触发 `useEffect` 的回调。

### useState

第一步就是现实一个简易的状态，这里模仿 React 官方 `useState` 的签名，我们也返回一个元组，分别是状态和更新其方法。

```ts
export type Getter<T> = () => T;
export type Setter<T> = (newValue: T | ((oldValue: T) => T)) => void;
export type UseState = <T>(value: T) => [Getter<T>, Setter<T>];

const useState: UseState = (value) => {
  const getter: Getter<typeof value> = () => {
    return value;
  };

  const setter: Setter<typeof value> = (updater) => {
    const newState =
      updater instanceof Function ? updater(value) : updater;
    if (value === newState) return;
    value = newState;
  };

  return [getter, setter];
};

export { useState };
```

这样看似很美好，我们利用函数的参数和闭包实现了一个状态，并在调用设置状态函数时，更新该状态。在调用 `getter()` 时返回该状态。但是它无法和 React 一起使用，因为 React 的 `useState` 重点不仅仅是对一个值的设置，而是在状态更新时更新 React 组件。我们的 `useState` 只实现了一个功能，对状态的管理，我们还需要实现更新 React 组件才能和 React 一起使用。

我们的重点不是在如何实现一个 React，所以更新组件就交给真正的 `useState` 来做。我们通过在我们自己状态更新时，调用 React 的 `useState` 来更新组件。这样就通过借用官方的 `useState` 来帮助我们更新组件，从而实现一个简易的状态。

```ts
const useState: UseState = (value) => {
  const state = useRef(value);
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [_, update] = useUpdate({});

  const getter: Getter<typeof value> = () => {
    return state.current;
  };

  const setter: Setter<typeof value> = (updater) => {
    const newState =
      updater instanceof Function ? updater(state.current) : updater;
    if (state.current === newState) return;
    state.current = newState;
    update({});
  };

  return [getter, setter];
};
```

使用它的方式和官方 hooks 没有区别：

```tsx
function App() {
  console.log('App updated');
  const [count, setCount] = useState(0);

  return (
    <>
      <button
        onClick={() => {
          setCount((d) => d + 1);
        }}
      >
        Update {count()}
      </button>
    </>
  );
}
```